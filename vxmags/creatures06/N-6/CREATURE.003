
                 ╔═══════════════════════════════════════════╗
                 ║ ■                                       ■ ║
                 ║      █▀ █▀▄ █▀ █▀█ ▀█▀ █ █ █▀▄ █▀ █▀▀     ║
                 ║  THE █  █▄▀ █▄ █▄█  █  █ █ █▄▀ █▄ █▄▄     ║
                 ║      █▄ █ █ █▄ █ █  █  █▄█ █ █ █▄ ▄▄█     ║
                 ║ ■                                       ■ ║
                 ╚═══════════════════════════════════════════╝

                                 Маскировка.

-------------------------------------------------------------------------------


        День добрый (излишне). Если вы уже можете написать стандартный RCE,
 но у вас все еще недостаточно знаний, чтобы скрыть его от антивирусного
"ебомулятора" (не помню, кто его так назвал, но название подходящее), и, тем
 более, избежать обнаружения в памяти, то неплохо было бы почитать эту статью.
 
        Для начала - небольшой совет: приступайте к маскировке после того,
 как вы ПОЛНОСТЬЮ протестируете вирус на работоспособность, чтобы избежать
 после проблем с отладкой или поимкой его, если вдруг он выйдет из-под
 контроля :)

        Маскировка резидентного вируса делится на две части - маскировка в
 памяти и сокрытие вирусного кода на диске, которое, в свою очередь, тоже
 имеет разделы - это шифровка (полиморфность) и антиэвристика.
        В свою очередь антивирусный детектор неизвестных вирусов состоит также
 из двух компонент, из анализатора кода, определяющего вирусные признаки, и
 собственно символического исполнителя.

        Прошли уже те времена, когда простая конструкция

                     mov byte ptr files, '*'
                     ...
                     ...
                     ; заражение
                     ...
              files: db '1.com',0

 позволяла избавиться от определения "возможно инфицирован"... Теперь
 анализаторы практически универсальны, поэтому ВСЕГДА тело вируса шифруется
(если предполагается его жизнеспособность).
        Можно, конечно, как-нибудь извратиться, но скоро не останется иного
 пути избавления от детектирования, кроме как текст на HLL :)

        Методов шифровки существует много, но лучше все-ж придумать свой,
 чтобы не повторяться, в этом случае работенки для avirs прибавится.


        Тут то и вступает в дело эротический анализатор, разъебывающий код
 байт за байтом путем символического исполнения команд РАСШИФРОВЩИКА.
  Который, по идее, всегда должен присутствовать и приводить к желаемому
 результату. По идее антивирусников. Но здесь уместно чукотское выражение
"однако..."

        Существует куча особенностей машины, которые анализатор не в состоянии
 проэмулировать. Это могут быть операции с портами, пересылка данных в
 различные жопные участки памяти, типа таблицы векторов (хотя в win95 такого
 лучше не делать), трюки с аппаратными прерываниями, стеком, девайсами,
 контроллерами, недокументированными функциями системы, exeption'ами...
  Вариантов много. Чем и привлекательна такая деятельность. Тут я призываю
 вас к творчеству и исследовательским работам.

         Но с чего мы начали? "В памяти компьютера возможно нахождение..."
 Да-да. И тут антиэвристика не слишком эффективна, поскольку int 21 не
 исполняется символически, а ТРАССИРУЕТСЯ. Для тех, кто не знает, в чем
 смысл сего страшного слова, скажу, что придумано это было для отладки,
 а работает так - если установлен (set) флаг трассировки (TF), то после
 исполнения каждой команды вызывается обработчик int 1.

                     D     B     G     E
                        E     U     G     R  ??!!! 8-()
                        
         Ага! :) Ну а антивирусы используют это для нахождения вирусного кода
 в памяти. И вовсе не обязательно шифроваться. Как вы понимаете, достаточно
 анализировать TF, чтобы понять, трассируют нас али нет, и принять меры.
         В качестве мер применялся, скажем, jump куда-то в жопень, от чего
 DrWEB, например, просто вис. Но мера эта плохая - юзер должен испытывать
 ложное чувство безопасности. Поэтому простой iret тоже подойдет.

!                                                                             !
         И помните - тот же DrWEB ругается В ЛЮБОМ СЛУЧАЕ, если int 21h
 указывает на конец памяти!

!                                                                             !

        Описываемый прием называется антитрассировочный код. Существует
 еще "анти-антитрассировка", когда при исполнении команд pushf, int и
 других, получающих флаги, флаги ставились левые. Казалось бы, выхода нет.
 Однако посмотрите сюда:
                         push cs
                         pop cs
                         pushf      ;)
 Скорее всего, вам знакома эта конструкция. Если же нет, попробуйте ee
 оттрассировать (какое неприличное слово). Игра продолжается!